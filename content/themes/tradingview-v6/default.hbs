<!DOCTYPE html>
<html lang="{{@site.locale}}">
<head>

	{{!-- Basic meta - advanced meta is output with {{ghost_head}} below --}}
	<title>{{meta_title}}</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	{{!-- Preload main styles and scripts for better performance --}}
	<link rel="preload" as="style" href="{{asset "built/screen.css"}}">
	<link rel="preload" as="script" href="{{asset "built/source.js"}}">

	{{!-- Theme assets - use the {{asset}} helper to reference styles & scripts, this will take care of caching and cache-busting automatically --}}
	<link rel="stylesheet" type="text/css" href="{{asset "built/screen.css"}}">
	<link rel="stylesheet" type="text/css" href="{{asset "css/style.css"}}">

	{{!-- Custom background color --}}
	<style>
		:root {
			--background-color: {{@custom.site_background_color}}
		}
	</style>

	<script>
		/* The script for calculating the color contrast has been taken from
		https://gomakethings.com/dynamically-changing-the-text-color-based-on-background-color-contrast-with-vanilla-js/ */
		var accentColor = getComputedStyle(document.documentElement).getPropertyValue('--background-color');
		accentColor = accentColor.trim().slice(1);

		if (accentColor.length === 3) {
			accentColor = accentColor[0] + accentColor[0] + accentColor[1] + accentColor[1] + accentColor[2] + accentColor[2];
		}

		var r = parseInt(accentColor.substr(0, 2), 16);
		var g = parseInt(accentColor.substr(2, 2), 16);
		var b = parseInt(accentColor.substr(4, 2), 16);
		var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
		var textColor = (yiq >= 128) ? 'dark' : 'light';

		document.documentElement.className = `has-${textColor}-text`;
	</script>

	{{!-- This tag outputs all your advanced SEO meta, structured data, and other important settings, it should always be the last tag before the closing head tag --}}
	{{ghost_head}}

	{{!-- Load Vue, Axios, date-fns BEFORE body to ensure availability --}}
	{{> "external-libs"}}

	{{!-- Tailwind CSS for utility classes --}}
	<script src="https://cdn.tailwindcss.com"></script>

</head>
<body class="{{body_class}} has-{{#match @custom.title_font "Elegant serif"}}serif{{else match @custom.title_font "Consistent mono"}}mono{{else}}sans{{/match}}-title has-{{#match @custom.body_font "Elegant serif"}}serif{{else}}sans{{/match}}-body">

<div class="gh-viewport">
	
	{{> "components/navigation" navigationLayout=@custom.navigation_layout}}

	{{{body}}}
	
	{{> "components/footer"}}
	
</div>

{{#is "post, page"}}
	{{> "lightbox"}}
{{/is}}

{{!-- Scripts - handle responsive videos, infinite scroll, and navigation dropdowns --}}
<script src="{{asset "built/source.js"}}"></script>

{{!-- Ghost outputs required functional scripts with this tag, it should always be the last thing before the closing body tag --}}
{{ghost_foot}}

{{!-- Initialize Vue Apps after all scripts loaded --}}
<script>
console.log('=== Init Script Loaded v2.0 ===');
console.log('Vue:', typeof Vue);
console.log('axios:', typeof axios);
console.log('dateFns:', typeof dateFns);

// Wait for DOM to be ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('=== DOM Ready ===');
    console.log('appSentiment element:', document.getElementById('appSentiment'));
    console.log('appNews element:', document.getElementById('appNews'));

    if (typeof Vue !== 'undefined') {
        const { ref, onMounted, onBeforeUnmount } = Vue;

        // Sentiment App
        const sentimentEl = document.getElementById('appSentiment');
        console.log('[Sentiment] Element found:', !!sentimentEl);
        if (sentimentEl) {
        try {
            Vue.createApp({
                setup() {
                    const fetchedSentiments = ref([]);
                    const fetchSentiments = async () => {
                        try {
                            console.log('[Sentiment] Fetching with axios...');
                            const response = await axios.get('https://api.fastbull.com/fastbull-macro-data-service/api/v2/getIndexSpeculative', {
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'Accept': '*/*'
                                }
                            });
                            console.log('[Sentiment] Response:', response.data);
                            console.log('[Sentiment] bodyMessage type:', typeof response.data.bodyMessage);
                            console.log('[Sentiment] bodyMessage sample:', response.data.bodyMessage?.substring ? response.data.bodyMessage.substring(0, 100) : response.data.bodyMessage);

                            const data = response.data;
                            if (typeof data.bodyMessage === "string") {
                                console.log('[Sentiment] Parsing string...');
                                const parsedData = JSON.parse(data.bodyMessage);
                                console.log('[Sentiment] Parsed array length:', parsedData.length);
                                fetchedSentiments.value = Array.isArray(parsedData) ? parsedData : Object.values(parsedData);
                            } else if (Array.isArray(data.bodyMessage)) {
                                console.log('[Sentiment] Already array');
                                fetchedSentiments.value = data.bodyMessage;
                            } else if (data.bodyMessage && typeof data.bodyMessage === 'object') {
                                console.log('[Sentiment] Object, converting to array');
                                fetchedSentiments.value = Object.values(data.bodyMessage);
                            } else if (data.data) {
                                console.log('[Sentiment] Using data.data fallback');
                                fetchedSentiments.value = Array.isArray(data.data) ? data.data : Object.values(data.data);
                            } else {
                                console.warn('[Sentiment] No valid data structure found!', data);
                            }
                            console.log('[Sentiment] Final array:', fetchedSentiments.value);
                            console.log('[Sentiment] Loaded:', fetchedSentiments.value.length);
                        } catch (error) {
                            console.error("[Sentiment] Error:", error);
                        }
                    };
                    onMounted(() => fetchSentiments());
                    const formatPercentage = (value) => {
                        const numValue = parseFloat(value);
                        return numValue ? new Intl.NumberFormat("en-US", {
                            style: "percent",
                            minimumFractionDigits: 1,
                            maximumFractionDigits: 1,
                        }).format(numValue / 100) : "0.0%";
                    };
                    const getStylePercent = (item, type = "long") => {
                        const value = parseFloat(type === "long" ? item.longValue : item.shortValue);
                        return { width: value > 0 ? value + '%' : "0%" };
                    };
                    return { fetchedSentiments, formatPercentage, getStylePercent };
                },
            }).mount("#appSentiment");
            console.log('[Sentiment] Vue app mounted successfully');
        } catch (e) {
            console.error('[Sentiment] Mount error:', e);
        }
    }

    // News App
    if (document.getElementById('appNews') && typeof axios !== 'undefined' && typeof dateFns !== 'undefined') {
        try {
            Vue.createApp({
                setup() {
                    const socket = ref(null);
                    const fetchedNews = ref({ pageDatas: [] });
                    const isLoading = ref(true);
                    
                    // Move formatDate inside setup to be available in template
                    const formatDate = (timestamp, dateFormat = 'dd-MM-yyyy HH:mm:ss') => {
                        const date = new Date(timestamp);
                        return isNaN(date.getTime()) ? '' : dateFns.format(date, dateFormat);
                    };
                    
                    const fetchNews = async () => {
                        try {
                            console.log('[News] üì• Fetching initial news...');
                            isLoading.value = true;
                            const response = await axios.get('https://api.fastbull.com/fastbull-news-service/api/getNewsPageByTagIds', {
                                headers: { 'Content-Type': 'application/json', 'langId': 10 },
                                params: { pageSize: 50 }
                            });
                            console.log('[News] Response:', response.data);
                            const newsData = JSON.parse(response.data.bodyMessage);
                            fetchedNews.value = newsData;
                            console.log('[News] ‚úÖ Loaded:', newsData.pageDatas?.length, 'items');
                            console.log('[News] Sample item:', newsData.pageDatas?.[0]);
                        } catch (error) {
                            console.error('[News] ‚ùå Fetch error:', error);
                        } finally {
                            isLoading.value = false;
                        }
                    };
                    const connectWebSocket = () => {
                        socket.value = new WebSocket('wss://wsspush.fastbull.com/news?langId=10');
                        socket.value.onopen = () => {
                            console.log('[News] ‚úÖ WebSocket connected successfully');
                            
                            // TEST: Add a fake news after 3 seconds to verify Vue reactivity
                            setTimeout(() => {
                                console.log('[News] üß™ TEST: Adding fake news item...');
                                const fakeNews = {
                                    newsId: 'test-' + Date.now(),
                                    newsTitle: 'üß™ TEST TIN TH·ª¨ NGHI·ªÜM - ' + new Date().toLocaleTimeString(),
                                    releasedDate: Date.now(),
                                    important: true
                                };
                                fetchedNews.value.pageDatas.unshift(fakeNews);
                                console.log('[News] üß™ TEST: Fake news added. Total:', fetchedNews.value.pageDatas.length);
                                console.log('[News] üß™ TEST: Array is reactive?', Array.isArray(fetchedNews.value.pageDatas));
                            }, 3000);
                        };
                        socket.value.onmessage = (event) => {
                            if (event.data instanceof Blob) {
                                const reader = new FileReader();
                                reader.onload = () => {
                                    try {
                                        const content = reader.result.trim();
                                        
                                        // Skip heartbeat/ping messages (just numbers)
                                        if (/^\d+$/.test(content)) {
                                            console.log('[News] üíì Heartbeat:', content);
                                            return;
                                        }
                                        
                                        console.log('[News] üì® Blob content:', content.substring(0, 200));
                                        const jsonData = JSON.parse(content);
                                        console.log('[News] üì¶ Parsed JSON keys:', Object.keys(jsonData));
                                        
                                        if (jsonData.messageInfo) {
                                            let newsItem;
                                            // Check if messageInfo is already an object or needs parsing
                                            if (typeof jsonData.messageInfo === 'string') {
                                                console.log('[News] üîÑ Parsing messageInfo string...');
                                                newsItem = JSON.parse(jsonData.messageInfo);
                                            } else {
                                                console.log('[News] üìÑ messageInfo is object');
                                                newsItem = jsonData.messageInfo;
                                            }
                                            console.log('[News] üÜï NEW ITEM FULL DATA:', JSON.stringify(newsItem, null, 2));
                                            console.log('[News] üîë Item keys:', Object.keys(newsItem));
                                            console.log('[News] üìù Title:', newsItem.newsTitle || newsItem.title);
                                            console.log('[News] üÜî ID:', newsItem.newsId || newsItem.id);
                                            console.log('[News] üìÖ Date:', newsItem.releasedDate || newsItem.date);
                                            
                                            console.log('[News] üìä BEFORE ADD - Array length:', fetchedNews.value.pageDatas.length);
                                            fetchedNews.value.pageDatas.unshift(newsItem);
                                            console.log('[News] üìä AFTER ADD - Array length:', fetchedNews.value.pageDatas.length);
                                            console.log('[News] ‚úÖ ADDED! Total items:', fetchedNews.value.pageDatas.length);
                                        } else {
                                            console.warn('[News] ‚ö†Ô∏è No messageInfo. Keys:', Object.keys(jsonData));
                                        }
                                    } catch (error) {
                                        console.error('[News] ‚ùå Blob parse error:', error, 'Content:', reader.result);
                                    }
                                };
                                reader.readAsText(event.data);
                            } else {
                                try {
                                    console.log('[News] Raw text data:', event.data);
                                    const jsonData = JSON.parse(event.data);
                                    console.log('[News] Parsed JSON:', jsonData);
                                    
                                    if (jsonData.messageInfo) {
                                        let newsItem;
                                        // Check if messageInfo is already an object or needs parsing
                                        if (typeof jsonData.messageInfo === 'string') {
                                            newsItem = JSON.parse(jsonData.messageInfo);
                                        } else {
                                            newsItem = jsonData.messageInfo;
                                        }
                                        console.log('[News] üÜï New item:', newsItem);
                                        fetchedNews.value.pageDatas.unshift(newsItem);
                                        console.log('[News] ‚úÖ Added to list. Total:', fetchedNews.value.pageDatas.length);
                                    } else {
                                        console.warn('[News] ‚ö†Ô∏è No messageInfo in data:', jsonData);
                                    }
                                } catch (error) {
                                    console.error('[News] ‚ùå Parse error:', error, 'Data:', event.data);
                                }
                            }
                        };
                        socket.value.onerror = (error) => {
                            console.error('[News] ‚ùå WebSocket error:', error);
                        };
                        socket.value.onclose = (event) => {
                            console.log('[News] ‚ö†Ô∏è WebSocket closed. Code:', event.code, 'Reason:', event.reason);
                            console.log('[News] üîÑ Reconnecting in 5 seconds...');
                            setTimeout(connectWebSocket, 5000);
                        };
                    };
                    onMounted(async () => {
                        console.log('[News] üöÄ Component mounted, starting initialization...');
                        await fetchNews();
                        console.log('[News] üì° Connecting WebSocket...');
                        connectWebSocket();
                    });
                    onBeforeUnmount(() => {
                        console.log('[News] üõë Component unmounting, closing socket...');
                        if (socket.value) socket.value.close();
                    });
                    return { fetchedNews, formatDate, isLoading };
                }
            }).mount('#appNews');
            console.log('[News] ‚úÖ Vue app mounted successfully');
        } catch (e) {
            console.error('[News] ‚ùå Mount error:', e);
        }
    } else {
        console.log('[News] ‚ö†Ô∏è appNews element not found or dependencies missing');
        console.log('  - appNews element:', document.getElementById('appNews'));
        console.log('  - axios:', typeof axios);
        console.log('  - dateFns:', typeof dateFns);
    }
    
    } else {
        console.error('Vue not available!');
    }
});
</script>

<script>
    /*Scroll to Top*/
const scrollTopBtn = document.querySelector('.js-scroll-top');
if (scrollTopBtn) {
  scrollTopBtn.onclick = () => {
    window.scrollTo({top: 0, behavior: 'smooth'});
  }
  
  const progressPath = document.querySelector('.scroll-top path');
  const pathLength = progressPath.getTotalLength();
  progressPath.style.transition = progressPath.style.WebkitTransition = 'none';
  progressPath.style.strokeDasharray = `${pathLength} ${pathLength}`;
  progressPath.style.strokeDashoffset = pathLength;
  progressPath.getBoundingClientRect();
  progressPath.style.transition = progressPath.style.WebkitTransition = 'stroke-dashoffset 10ms linear';		
  const updateProgress = function() {
    const scroll = window.scrollY || window.scrollTopBtn || document.documentElement.scrollTopBtn;

    const docHeight = Math.max(
      document.body.scrollHeight, document.documentElement.scrollHeight,
      document.body.offsetHeight, document.documentElement.offsetHeight,
      document.body.clientHeight, document.documentElement.clientHeight
    );

    const windowHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

    const height = docHeight - windowHeight;
    var progress = pathLength - (scroll * pathLength / height);
    progressPath.style.strokeDashoffset = progress;
  }

  updateProgress();
  const offset = 100;

  window.addEventListener('scroll', function(event) {
    updateProgress();

    //Scroll back to top
    const scrollPos = window.scrollY || window.scrollTopBtn || document.getElementsByTagName('html')[0].scrollTopBtn;
    scrollPos > offset ? scrollTopBtn.classList.add('is-active') : scrollTopBtn.classList.remove('is-active');

  }, false);
}
</script>

</body>
</html>
